use crate::schema::{Field, Schema, TypeRef};
use anyhow::Result;
use std::collections::HashSet;
use std::fs;
use std::path::Path;

pub struct CurlExporter {
    schema: Schema,
    base_url: String,
}

impl CurlExporter {
    pub fn new(schema: Schema, base_url: String) -> Self {
        Self { schema, base_url }
    }

    pub fn export(&self, output_path: &Path) -> Result<ExportStats> {
        let mut script = String::new();
        let mut stats = ExportStats::default();

        // Script header
        script.push_str("#!/bin/bash\n");
        script.push_str("# GraphQL API cURL commands\n");
        script.push_str(&format!("# Generated by gqlmap for: {}\n", self.base_url));
        script.push_str("#\n");
        script.push_str("# Usage: ./queries.sh [operation_name]\n");
        script.push_str("# Without arguments, lists all available operations\n\n");

        script.push_str(&format!("BASE_URL=\"{}\"\n\n", self.base_url));

        // Add helper function
        script.push_str(r#"gql_request() {
    local query="$1"
    local variables="${2:-{}}"
    curl -s -X POST "$BASE_URL" \
        -H "Content-Type: application/json" \
        -d "{\"query\": \"$(echo "$query" | tr '\n' ' ' | sed 's/"/\\"/g')\", \"variables\": $variables}"
}

"#);

        let mut operations = Vec::new();

        // Generate query functions
        if let Some(query_type) = self.schema.get_query_type() {
            if let Some(fields) = &query_type.fields {
                script.push_str("# ========== QUERIES ==========\n\n");

                for field in fields.iter().filter(|f| !f.name.starts_with("__")) {
                    let func = self.generate_function(field, "query");
                    script.push_str(&func);
                    script.push_str("\n");
                    operations.push(field.name.clone());
                    stats.queries += 1;
                }
            }
        }

        // Generate mutation functions
        if let Some(mutation_type) = self.schema.get_mutation_type() {
            if let Some(fields) = &mutation_type.fields {
                script.push_str("# ========== MUTATIONS ==========\n\n");

                for field in fields.iter().filter(|f| !f.name.starts_with("__")) {
                    let func = self.generate_function(field, "mutation");
                    script.push_str(&func);
                    script.push_str("\n");
                    operations.push(field.name.clone());
                    stats.mutations += 1;
                }
            }
        }

        // Add main dispatcher
        script.push_str("# ========== MAIN ==========\n\n");
        script.push_str("list_operations() {\n");
        script.push_str("    echo \"Available operations:\"\n");
        for op in &operations {
            script.push_str(&format!("    echo \"  - {}\"\n", op));
        }
        script.push_str("}\n\n");

        script.push_str("case \"$1\" in\n");
        for op in &operations {
            script.push_str(&format!("    {}) {};;", op, op));
            script.push_str("\n");
        }
        script.push_str("    \"\") list_operations;;\n");
        script.push_str("    *) echo \"Unknown operation: $1\"; list_operations; exit 1;;\n");
        script.push_str("esac\n");

        fs::write(output_path, script)?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(output_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(output_path, perms)?;
        }

        Ok(stats)
    }

    fn generate_function(&self, field: &Field, operation: &str) -> String {
        let selection = self.build_field_selection(&field.field_type, 0, &mut HashSet::new());
        let (query, variables) = self.build_query_and_vars(field, operation, &selection);

        let mut func = String::new();
        func.push_str(&format!("# {}\n", field.name));
        func.push_str(&format!("{}() {{\n", field.name));

        if field.args.is_empty() {
            func.push_str(&format!(
                "    gql_request '{}'\n",
                query.replace('\'', "'\"'\"'")
            ));
        } else {
            func.push_str(&format!("    local vars='{}'\n", variables));
            func.push_str(&format!(
                "    gql_request '{}' \"$vars\"\n",
                query.replace('\'', "'\"'\"'")
            ));
        }

        func.push_str("}\n");
        func
    }

    fn build_query_and_vars(&self, field: &Field, operation: &str, selection: &str) -> (String, String) {
        if field.args.is_empty() {
            let query = if selection.is_empty() {
                format!("{} {{ {} }}", operation, field.name)
            } else {
                format!("{} {{ {} {} }}", operation, field.name, selection)
            };
            return (query, "{}".to_string());
        }

        // Build variable definitions
        let var_defs: Vec<String> = field
            .args
            .iter()
            .map(|arg| {
                let type_str = self.type_ref_to_string(&arg.input_type);
                format!("${}: {}", arg.name, type_str)
            })
            .collect();

        // Build argument usage
        let arg_usage: Vec<String> = field
            .args
            .iter()
            .map(|arg| format!("{}: ${}", arg.name, arg.name))
            .collect();

        let query = if selection.is_empty() {
            format!(
                "{}({}) {{ {}({}) }}",
                operation,
                var_defs.join(", "),
                field.name,
                arg_usage.join(", ")
            )
        } else {
            format!(
                "{}({}) {{ {}({}) {} }}",
                operation,
                var_defs.join(", "),
                field.name,
                arg_usage.join(", "),
                selection
            )
        };

        // Build variables JSON
        let vars: Vec<String> = field
            .args
            .iter()
            .filter_map(|arg| {
                let value = self.build_arg_value(&arg.input_type, 0)?;
                Some(format!("\"{}\": {}", arg.name, value))
            })
            .collect();

        let variables = format!("{{ {} }}", vars.join(", "));

        (query, variables)
    }

    fn type_ref_to_string(&self, type_ref: &TypeRef) -> String {
        match type_ref.kind.as_str() {
            "NON_NULL" => {
                if let Some(ref of_type) = type_ref.of_type {
                    format!("{}!", self.type_ref_to_string(of_type))
                } else {
                    "String!".to_string()
                }
            }
            "LIST" => {
                if let Some(ref of_type) = type_ref.of_type {
                    format!("[{}]", self.type_ref_to_string(of_type))
                } else {
                    "[String]".to_string()
                }
            }
            _ => type_ref.name.clone().unwrap_or_else(|| "String".to_string()),
        }
    }

    fn build_arg_value(&self, type_ref: &TypeRef, depth: usize) -> Option<String> {
        if depth > 3 {
            return None;
        }

        match type_ref.kind.as_str() {
            "NON_NULL" | "LIST" => {
                if let Some(ref of_type) = type_ref.of_type {
                    self.build_arg_value(of_type, depth)
                } else {
                    None
                }
            }
            "SCALAR" => {
                let name = type_ref.name.as_deref()?;
                Some(
                    match name {
                        "String" | "ID" => "\"\"",
                        "Int" => "0",
                        "Float" => "0.0",
                        "Boolean" => "false",
                        _ => "\"\"",
                    }
                    .to_string(),
                )
            }
            "ENUM" => {
                let name = type_ref.name.as_deref()?;
                if let Some(enum_type) = self.schema.get_type(name) {
                    if let Some(values) = &enum_type.enum_values {
                        if let Some(first) = values.first() {
                            return Some(format!("\"{}\"", first.name));
                        }
                    }
                }
                None
            }
            "INPUT_OBJECT" => Some("{}".to_string()),
            _ => None,
        }
    }

    fn build_field_selection(
        &self,
        type_ref: &TypeRef,
        depth: usize,
        visited: &mut HashSet<String>,
    ) -> String {
        if depth > 2 {
            return String::new();
        }

        let base_name = match type_ref.get_base_type_name() {
            Some(name) => name,
            None => return String::new(),
        };

        let scalar_types = ["String", "Int", "Float", "Boolean", "ID"];
        if scalar_types.contains(&base_name) {
            return String::new();
        }

        if let Some(t) = self.schema.get_type(base_name) {
            if t.kind == "ENUM" || t.kind == "SCALAR" {
                return String::new();
            }
        }

        if visited.contains(base_name) {
            return String::new();
        }
        visited.insert(base_name.to_string());

        let object_type = match self.schema.get_type(base_name) {
            Some(t) if t.kind == "OBJECT" || t.kind == "INTERFACE" => t,
            _ => {
                visited.remove(base_name);
                return String::new();
            }
        };

        let fields = match &object_type.fields {
            Some(f) => f,
            None => {
                visited.remove(base_name);
                return String::new();
            }
        };

        let field_strs: Vec<String> = fields
            .iter()
            .filter(|f| !f.name.starts_with("__"))
            .take(10)
            .map(|f| {
                let sub = self.build_field_selection(&f.field_type, depth + 1, visited);
                if sub.is_empty() {
                    f.name.clone()
                } else {
                    format!("{} {}", f.name, sub)
                }
            })
            .collect();

        visited.remove(base_name);

        if field_strs.is_empty() {
            String::new()
        } else {
            format!("{{ {} }}", field_strs.join(" "))
        }
    }
}

#[derive(Default)]
pub struct ExportStats {
    pub queries: usize,
    pub mutations: usize,
}
